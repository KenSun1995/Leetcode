/**
 * 连续子数组的最大和：
 *          输入一个整型数组，数组里有正数也有负数，数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值. 时间复杂度O(n)
 */
/**
 * Input: [1,-2,3,10,-4,7,2,-5]
 * Output: 18                    ({3,10,-4,7,2})
 */
/**
 * 思路 1：从头开始遍历数组，进行累加，如果加完的和小于新加的数本身，则舍弃前面累加的，从新加的数处开始继续遍历
 *                             如果加完的和不小于新加的数本身但是比原有值变小了，则保存原有值，它可能是最大的结果。
 * 
 * 思路 2: 动态规划 
 *        与展示代码实现相同，思路异曲同工
 *        !!! 动态规划思路：先定义一个一维数组或二维数组，然后赋予dp[i][j]含义，然后找到关系式，然后知道要求dp[i][j]或相似的结果
 *                        然后计算出dp[][]的某些初始值，用动态规划，循环，根据关系式，得到要求的结果值，核心思想是使用先前的值
 */
/**
 * Robust: [], undefined
 */

var maxSubArray = function (nums) {
    if (!nums || nums.length <= 0) return;
    let curSum = 0;                                 // 记录当前和
    let maxSum = -Infinity;                         // 最大和，初始化为负无穷
    for (let i = 0; i < nums.length; i++) {
        if (curSum <= 0) {
            curSum = nums[i];                       // 如果当前和已经为负数了，那就应该舍弃，并从nums[i]开始算和
        } else {
            curSum += nums[i];                      // 如果和为正数，就说明再加一个数是有意义的，加
        }
        if (curSum > maxSum) {                      // 每次判断一下，加完的当前和是否是最大的，如果是，则更新maxSum
            maxSum = curSum;
        }
    }
    return maxSum;
};

(() => {
    let input = [1, -2, 3, 10, -4, 7, 2, -5];
    console.log(maxSubArray(input));
})()